% -*- latex -*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This text file is part of the lecture slides for
%%%% `Parallel Programming in MPI and OpenMP'
%%%% by Victor Eijkhout, copyright 2012-2024
%%%%
%%%% Tasks-slides.tex : slides about OpenMP workshare constructs
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{numberedframe}{Tasks}
  \begin{itemize}
  \item Loops generate `implicit tasks'\\
    need static number of iterations
  \item Also: `explicit tasks' \\
    can deal with dynamic work:
  \item 
    Example linked lists or trees
  \item Tasks are very flexible:\\
    you create work, it goes on a queue, gets executed later
  \end{itemize}
\begin{verbatim}
p = head_of_list();
while (!end_of_list(p)) {
#pragma omp task
  process( p );
  p = next_element(p);
}
\end{verbatim}
\end{numberedframe}

\begin{numberedframe}{Threads, tasks, queues}
  \begin{itemize}
  \item There is one queue (per team), not visible to the programmer.
  \item One thread starts generating tasks.
  \item Tasks can recursively generate tasks.
  \item You never know who executes what.
  \end{itemize}
  \includegraphics[scale=.1]{taskthread}
\end{numberedframe}

\begin{numberedframe}{Generation idiom}
\begin{lstlisting}
#pragma omp parallel
#pragma omp single
{
  ...
  #pragma omp task
  { ... }
  #pragma omp taskwait
}
\end{lstlisting}
\end{numberedframe}

\begin{exerciseframe}[taskfactor]
  \input ex:taskfactor
\end{exerciseframe}

\begin{numberedframe}{Task data space}
  \begin{itemize}
  \item Environment captured as \lstinline{firstprivate}
    unless explicitly otherwise
  \end{itemize}
\end{numberedframe}

\begin{numberedframe}{Task synchronization}
  Mechanisms for task synchronization:
  \begin{itemize}
  \item \indextermtt{taskwait}: wait for all previous tasks (not nested)
  \item \indextermtt{taskgroup}: wait for all tasks, including nested
  \item \indextermtt{depend}: synchronize on data items.
  \end{itemize}
\end{numberedframe}

\begin{numberedframe}{Example: tree traversal}
\begin{verbatim}
int process( node n ) {
  if (n.is_leaf)
    return n.value;
  for ( c : n.children) {
#pragma omp task
    process(c);
#pragma omp taskwait
  return sum_of_children();
}
\end{verbatim}
\end{numberedframe}

\begin{numberedframe}{Example: Fibonacci}
\begin{verbatim}
long fib(int n) {
  if (n<2) return n;
  else { long f1,f2;
#pragma omp task
  f1 = fib(n-1);
#pragma omp task
  f2 = fib(n-2);
#pragma omp taskwait
  return f1+f2;
}

#pragma omp parallel
#pragma omp single
  printf("Fib(50)=%ld",fib(50));
\end{verbatim}
(what is conceptually wrong with this example?)
\end{numberedframe}

\begin{numberedframe}{Fibonacci once more}
\begin{verbatim}
long fibs[100];
void fib(n) {
  if (n>=2) {
    #pragma omp task \
       depend( in:fibs[n-2],in:fibs[n-1] ) \
       depend( out:fibs[n] )
    fibs[n] = fibs[n-2]+fibs[n-1];
};

#pragma omp parallel
#pragma omp single
  for (i<50)
    fib(i);
\end{verbatim}
\end{numberedframe}

\endinput

\begin{numberedframe}{}
\begin{lstlisting}
\end{lstlisting}
  \begin{itemize}
  \item 
  \end{itemize}
\end{numberedframe}

\endinput

\begin{numberedframe}{}
\begin{lstlisting}
\end{lstlisting}
  \begin{itemize}
  \item 
  \end{itemize}
\end{numberedframe}

